Implicit context: VS Code automatically provides context to the chat prompt based on your current activity. The following information is implicitly included in the chat context:

The currently selected text in the active editor.
The file name or notebook name of the active editor.
If you're using ask mode or edit mode, the active file is automatically included as context.


#-mentions: In chat, you can explicitly refer to context by typing # followed by the context item you want to mention. This enables the AI to provide more relevant responses based on the specific context you are referring to. Type the # symbol in the chat input field to see a list of available context items.


Perform a codebase search: Instead of adding individual files manually, you can let VS Code find the right files from your codebase automatically. This can be useful when you don't know which files are relevant to your question. Add #codebase in your prompt or select Add Context > Tools > codebase to enable code search for your workspace.

================================================================================================================================================================
Exercise 2: Create an AI-Enabled Azure Web App
Estimated Duration: 45 Minutes
Overview
In this exercise, you will use GitHub Copilot Agent mode in Visual Studio Code to scaffold a GenAI summarizer web app, integrate Azure OpenAI capabilities, and validate the app locally. You’ll generate all necessary project files, configure AI endpoints and credentials, and test the application by providing input and troubleshooting errors. By the end, your web app will be enabled with advanced AI-powered summarization features and ready for deployment.

Objectives
In this exercise, you will complete the following tasks:

Task 1: Scaffold the Application Using Prompts
Task 2: Integrate AI Capabilities
Task 3: Local Testing and Validation
Task 1: Scaffold the Application Using Prompts
In this task, you will use GitHub Copilot Agent mode in Visual Studio Code to scaffold a GenAI summarizer web app by generating all necessary frontend, backend, and API integration files based on project requirements. You’ll set up a Python virtual environment, install dependencies, and launch the app servers, preparing your development environment for further AI integration and testing.



Copy the prompt provided below, paste it into the chat panel, and click Send.

Read requirements.md, feature-request.md, and architecture.md. 
Generate all necessary project files (frontend, backend, and API integration) to scaffold the GenAIsummarizer web app as described in these files.


Allow the agent a few minutes to generate and update the necessary files. You can monitor the progress and view newly created or modified files in the left file explorer panel.
Once the agent completes all the file creation and updation, it will ask to confirm whether to keep the files or undo the changes. Click on Keep (1) in the right chat panel. Then, click on Continue (2) for Python environment configuration.

Copilot asks to create a new virtual environment, so click on + Create Virtual Environment from the top search bar.
Note: Copilot may automatically create the virtual environment without prompting. If so, skip these steps and continue at step 11.

Note: The response generated by the above prompt may vary. If your prompt returns an error, press Ctrl + C in the terminal and run the prompt again. GitHub Copilot should automatically resolve the errors.

Select venv from the list, which will create a folder with the name .venv where it contains all the packages required for the app.
Select Python 3.13, which is used to create a Venv virtual environment.
Provide the name of the virtual environment as .venv and click Enter.

Next, select Install project dependecies to install the packages required for the application and click Enter

Select the requirements.txt (1) file, which contains a list of packages required for the app, and click on OK (2).


The agent will ask to confirm for the packages to be installed, click on Continue.
Once the files are saved, you can see a subfolder named summarizer-app created and many files created under it. Open and explore the files created.

Now, we can start the application to run. Copy the below prompt, paste it in the right chat panel, and click on Send.
start the application server from the virtual environment and simultaneously resolve any errors or issues that show up in terminal when the servers are running.
When the servers is running, copy the URL displayed in the terminal and open in your browser.
You can see your application running. Please note that the user interface and the features added in the application will vary every time.

Note: If you encounter errors while starting the application, press Ctrl+C in the terminal to stop the running process. The agent will then review the error messages and apply the required fixes automatically.

======================================================================================
Exercise 2: Task 1: Scaffold the Application Using Prompts

Task 2: Integrate AI Capabilities
In this task, you will update your web app to integrate Azure OpenAI capabilities. You'll configure the backend to use your Azure OpenAI endpoint, API key, and model name, modify the summarization logic to send user input to the AI model, and update the frontend to display the summarized output. This prepares your app to leverage advanced AI features for text summarization.

Navigate back to Visual Studio Code and stop the server by clicking Ctrl+C (1) in the terminal. Make sure to stop the server running in different terminals (2). You can also stop the server by providing a prompt to the agent like Stop the servers running (3).

Copy the below prompt and paste it in the chat panel to update the required files to use openai model by using openai endpoint, api key, and model name. Click on send.

Update the backend code to use Azure OpenAI
- Add configuration for Azure OpenAI endpoint, API key, and model name (read from environment variables).
- Modify the summarization logic to send user input text to the Azure OpenAI model.
- Return the summarized response from the model to the frontend.
- Update frontend code to send user input to the backend and display the summarized output.

You can monitor the file changes done by the agent. Once all changes are done, the agent will ask for confirmation to keep the changes or discard them. Click on Keep.

Before proceeding further, we need to have openai endpoint, api key, and a model name. Open the Azure portal using the link below.

https://portal.azure.com/
In the search bar, search for Microsoft Foundry (1) and select Microsoft Foundry (2) from the list.


In the AI Foundry window, from the left panel under Use with Foundry, select Azure OpenAI (1) and click on OpenAIService-1977373 (2).
Click on Go to Foundry portal.
Once the Microsoft Foundry portal opens, locate and copy both the API Key (1) and Azure OpenAI endpoint(2). Save these values in your notepad for use in the next steps.
In the left panel, click on Deployments (1) under Shared resources. Find the model name (2), copy it, and save it in your notepad for further use in the next steps.


Navigate back to Visual Studio Code, copy the below prompt, replace the placeholders with the values copied in previous steps. Paste the updated prompt in the chat panel and click on send.

Store and set these values in environment variables(.env file).
1. Azure OpenAI endpoint - <OPENAI_ENDPOINT>
2. Azure OpenAI API key - <OPENAI_API_KEY>
3. Azure OpenAI model name - <OPENAI_MODEL_NAME>


After the agent updates the .env file, click on Keep (1) and review its environment variables values (2) to ensure the correct values for the Azure OpenAI endpoint, API key, and model name are set before moving on to the next task.


Task 3: Local Testing and Validation
In this task, you will restart both the frontend and backend servers to validate your AI-enabled web app locally. You'll test the app by providing input and reviewing the summarized output, and use GitHub Copilot Agent to troubleshoot and fix any errors that arise during testing, ensuring your application runs smoothly before deployment.

Once all the changes are applied, restart application servers. This can be done easily by providing a prompt to the agent like Start the application.


Test your app by providing inputs and check the outputs provided.
=====================================================================================================================================================================
=====================================================================================================================================================================
=====================================================================================================================================================================
STEP 1: AGENT MODE:


PROMPT:

Read requirements.md, feature-request.md, and architecture.md. 
Generate all necessary project files (frontend, backend, and API integration) to scaffold the GenAIsummarizer web app as described in these files.




2.
start the application server from the virtual environment and simultaneously resolve any errors or issues that show up in terminal when the servers are running.


3.
Update the backend code to use Azure OpenAI
- Add configuration for Azure OpenAI endpoint, API key, and model name (read from environment variables).
- Modify the summarization logic to send user input text to the Azure OpenAI model.
- Return the summarized response from the model to the frontend.
- Update frontend code to send user input to the backend and display the summarized output.





Task 1: Modularize Application Logic
In this task, you will use GitHub Copilot Agent mode to refactor your web app by modularizing the AI summarization and input parsing logic into a dedicated service file. You'll separate the main app’s routing and user interaction from the core AI and multi-format input processing, improving code organization and maintainability for future enhancements.

Copy the prompt provided below, paste it into the chat panel, and click Send.



Read feature-request.md and Refactor the code so that all AI summarization and input parsing logic (text, PDF, DOCX, URL) is moved into a dedicated service file (e.g., summarizer service). 
Ensure the main app only handles routing and user interaction, while the service handles AI logic and multi-format input processing.








1. Enhance the summarizer service using feature-request.md. 
- Add retry logic with exponential backoff for Azure OpenAI API calls. 
- Implement error handling and logging for failed requests. 
- Ensure errors return user-friendly messages in both API responses and UI.



2. testing

Based on feature-request.md, generate unit tests for summarizer service. 
- Cover multi-format input parsing (text, PDF, DOCX, URL), and configurable summary length.
- Add test cases for retry logic and error handling. 
- Provide instructions to run the tests and verify correctness.





3. deployment
Generate a GitHub Actions workflow file named deploy.yml to build and deploy a GenAI summarizer web app to Azure Web App.  
Requirements:  
- OS: Linux  
- Runtime: Python  
- Publish method: Code  
- App Service Plan: Basic B1 (already created)  
- Trigger: push to main branch  
- Secrets to use: AZURE_CREDENTIALS, AZURE_WEBAPP_NAME, AZURE_SUBSCRIPTION_ID, AZURE_RESOURCE_GROUP  
- Steps:  
  1. Checkout code  
  2. Azure login with azure/login@v2 using AZURE_CREDENTIALS  
  3. Deploy to Azure Web App with azure/webapps-deploy@v3, using app name, slot=production, package path `summarizer-app`, and resource group  
  4. Run `az webapp config set` to set startup file to startup.sh
  
  
  




4. contextual planner prompt:


---
description: Generate an implementation plan for new features or refactoring existing code.
tools: ['codebase', 'fetch', 'findTestFiles', 'githubRepo', 'search', 'usages']
model: Claude Sonnet 4
---
# Planning mode instructions
You are in planning mode. Your task is to generate an implementation plan for a new feature or for refactoring existing code.
Don't make any code edits, just generate a plan.
The plan consists of a Markdown document that describes the implementation plan, including the following sections:
- Overview: A brief description of the feature or refactoring task.
- Requirements: A list of requirements for the feature or refactoring task.
- Implementation Steps: A detailed list of steps to implement the feature or refactoring task.
- Testing: A list of tests that need to be implemented to verify the feature or refactoring task.





---
applyTo: "**/*.py"
---
# Feature Request Prompt
The application needs to be implemented with this feature: **Batch Processing**
- All actions and errors are logged for audit and debugging.
- User-friendly error messages in both UI and API.
- Logs must include timestamp, user ID, action, and error details.








Add real-time text input streaming to the summarization app so that the summary updates live as the user types. Provide a high-level plan before implementing.
Proceed with this plan and implement the feature
Improve the UI of the summarization app with a clean layout, larger text areas, and a styled button. Provide a high-level plan before implementing.
Add simple loading animation or spinner while the summary is being generated.
Add a fade-in animation when displaying the generated summary.







========================================================================
architecture.md

I want to build a GenAIsummarizer app that will include the following:

- Accepts input as plain text, PDF, DOCX, and web URLs
- Generates concise summaries (configurable length)
- Provides REST API endpoints for integration
- Offers a simple web UI for manual summarization
- Allows batch processing of files
- Logging and error handling

It should be in one app

The directory tree for the GenAIsummarizer App:

summarizer-app/
├── backend/
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py                # Application entry point, starts web server
│   │   ├── api.py                 # REST API endpoints (summarize, batch, history)
│   │   ├── ui.py                  # Web UI backend logic (Python)
│   │   ├── summarizer/
│   │   │   ├── __init__.py
│   │   │   ├── utils.py           # Text extraction, format parsing (PDF, DOCX, URL)
│   │   │   └── engine.py          # Summarization logic, configurable length
│   │   ├── config.py              # App configuration (env vars, summary length)
│   │   ├── logger.py              # Logging setup (actions, errors)
│   │   └── errors.py              # Custom error handling
│   ├── tests/
│   │   ├── test_api.py             # Unit tests for API endpoints
│   │   ├── test_summarizer.py      # Unit tests for summarization logic
│   │   ├── test_auth.py            # Unit tests for authentication
│   │   └── test_history.py         # Unit tests for history tracking
├── frontend/
│   ├── templates/                 # Jinja2 Python templates for UI
│   └── __init__.py                # Python module for frontend logic
└── requirements.txt               # Python dependencies
├── README.md                      # Setup and usage documentation
├── run.py                         # CLI to start app (web server, batch jobs)
└── .env                           # Environment variables (not in version control)
└── startup.sh                     # Startup script for deployment

The files should be organized and created in the above provided directory structure.

The use and function of each file is as follows:
- backend/app/main.py: starts the app, loads config, initializes logger, and mounts API/UI.
- backend/app/api.py: exposes endpoints for summarization, batch processing, and history. Calls summarizer/engine.py for summary generation and history.py for storing/retrieving summaries.
- backend/app/ui.py: serves the dashboard, upload forms, and history views. Communicates with api.py via Python.
- backend/app/summarizer/utils.py: extracts text from PDF, DOCX, or URLs. Used by both API and UI.
- backend/app/summarizer/engine.py: generates summaries based on configurable length. Called by API/UI.
- backend/app/config.py: loads environment variables and settings (e.g., summary length, auth tokens).
- backend/app/logger.py: logs all actions and errors for audit/debugging. Used throughout the app.
- backend/app/errors.py: defines custom error classes and handlers for API/UI.
- frontend/templates/: Jinja2 Python templates for dashboard, upload, history, etc.
- requirements.txt: Python dependencies for backend.
- run.py: CLI to start app (web server, batch jobs).
- .env: Environment variables (not in version control).
- startup.sh: Startup script for deployment (e.g., Azure Web App).


Create a requirements.txt file with the following Python required packages:
fastapi
uvicorn
pydantic
python-docx
PyPDF2
requests
beautifulsoup4
openai
jinja2
python-jose
aiofiles
loguru
python-multipart
python-dotenv

When generating or updating requirements.txt, always copy the full list of Python packages exactly as specified in architecture.md. Do not omit, add, or modify any package names. If requirements.txt already exists, replace its contents with the complete, exact list from architecture.md. Double-check that every package from architecture.md is present in requirements.txt.

When generating or updating run.py, always set the host to "127.0.0.1" for local development. Do not use "0.0.0.0" unless explicitly requested for deployment. The default port should be read from the PORT environment variable, falling back to 8000 if not set.

When generating or updating startup.sh, always use the exact commands and structure as shown below. Do not add, remove, or modify any commands unless explicitly requested. The script must:

- Upgrade pip
- Install dependencies from requirements.txt if it exists
- Start the app using python run.py
- Exit immediately if any command fails
- Print clear status messages for each step
- Example startup.sh:

#!/bin/bash
set -e
echo "=== Installing Python dependencies ==="
if [ -f requirements.txt ]; then
  pip install --upgrade pip
  pip install -r requirements.txt
else
  echo "No requirements.txt found, skipping pip install."
fi
echo "=== Starting the app ==="
python run.py


All the packages listed in requirements.txt file should be installed in the Python environment.

All of the backend app will be in summarizer-app/backend and all frontend files in summarizer-app/frontend.

Both backend and frontend are implemented in Python only.

Use a Python virtual environment and install all python dependencies from backend/requirements.txt in this workspace. To run tests, use pytest from the backend/tests/ directory. Aim for at least 80% code coverage. Store secrets and configuration in environment variables, not in code.

Follow this structure and instructions to avoid errors and ensure a smooth deployment.

Let's think about this step by step.









REQUIREMENTS.MD
==========================================================================================================================================
GenAIsummarizer app is a self-hosted Python application that summarizes text documents, web pages, and user input. The application should be easy to deploy on-premises or in a cloud web app. It is implemented entirely in Python, including the web UI and REST API. Both the backend and frontend will be in Python only.

The Functional Requirements of this app is:
- Accepts input as plain text, PDF, DOCX, and web URLs
- Maximum file size for uploads is 10MB
- Generates concise summaries (configurable length: short, medium, long)
- Provides REST API endpoints for integration
- Offers a simple, responsive web UI for manual summarization (Python/Jinja2 templates)
- Allows batch processing of up to 10 files per request
- Logging and error handling with user-friendly messages
- API authentication via JWT tokens
- History of previous summaries per user

The Non-Functional Requirements of this app is:
- Self-hosted: runs on Windows or Linux servers
- Python 3.8+ compatibility
- Minimal external dependencies, all listed in requirements.txt
- Easy installation using pip and virtual environment
- Responsive and accessible web UI (Python/Jinja2 templates, keyboard navigation, screen reader support)
- Configured with Azure OpenAI model using environment variables for keys and endpoints
- Scalable for large document sets (horizontal scaling supported)
- Documentation for setup, usage, and troubleshooting
- Error messages are clear and actionable for users
- All configuration and secrets are managed via environment variables

Setup Checklist:
1. Create and activate a Python virtual environment.
2. Install dependencies from requirements.txt.
3. Run the app using run.py.
4. Access the web UI and REST API.
5. When the app is successfully running, set environment variables for Azure OpenAI keys and endpoints.
6. Access the web UI and REST API and test the features.
5. Review documentation in README.md for usage and troubleshooting.

Note: Both backend and frontend are implemented in Python only.







feature request.md
==========================================================================================================================================
The Features which are added for GenAIsummarizer Application are:

1. Multi-format Input Support
- Users can upload or paste text, PDF, DOCX, or provide a web URL.
- The system parses and extracts text from each format.
- If an unsupported format or corrupted file is uploaded, the app displays a clear error message.

2. Configurable Summary Length
- Users can select short, medium, or long summaries.
- API accepts a parameter for summary length.
- Example: summary_length=short|medium|long

3. REST API Endpoints
- Endpoints for submitting documents, retrieving summaries, and batch processing.
- API authentication via JWT tokens.
- Example endpoint: POST /api/summarize
- API returns user-friendly error messages for invalid requests.

4. Web User Interface
- Simple dashboard for uploading files, entering text, and viewing summaries.
- History of previous summaries per user.
- UI is responsive and accessible (keyboard navigation, screen reader support).
- Notifications for completion and errors are shown as popups.

5. Batch Processing
- All actions and errors are logged for audit and debugging.
- User-friendly error messages in UI and API.
- Logs include timestamp, user ID, action, and error details.

6. Logging & Error Handling
- All actions and errors are logged for audit and debugging.
- User-friendly error messages in UI and API.

Note: Both the web UI and REST API are implemented in Python only.

User Request Example:
As a user, I want to upload a PDF and receive a short summary, so I can quickly understand the document content.

















































































====================================================================================================================================


https://github.com/odl-user-1977373_clabs/github-ai-assisted-coding-1977373

requirements.md
=====================================================================

GenAIsummarizer app is a self-hosted Python application that summarizes text documents, web pages, and user input. The application should be easy to deploy on-premises or in a cloud web app. It is implemented entirely in Python, including the web UI and REST API. Both the backend and frontend will be in Python only.

The Functional Requirements of this app is:
- Accepts input as plain text, PDF, DOCX, and web URLs
- Maximum file size for uploads is 10MB
- Generates concise summaries (configurable length: short, medium, long)
- Provides REST API endpoints for integration
- Offers a simple, responsive web UI for manual summarization (Python/Jinja2 templates)
- Allows batch processing of up to 10 files per request
- Logging and error handling with user-friendly messages
- API authentication via JWT tokens
- History of previous summaries per user

The Non-Functional Requirements of this app is:
- Self-hosted: runs on Windows or Linux servers
- Python 3.8+ compatibility
- Minimal external dependencies, all listed in requirements.txt
- Easy installation using pip and virtual environment
- Responsive and accessible web UI (Python/Jinja2 templates, keyboard navigation, screen reader support)
- Configured with Azure OpenAI model using environment variables for keys and endpoints
- Scalable for large document sets (horizontal scaling supported)
- Documentation for setup, usage, and troubleshooting
- Error messages are clear and actionable for users
- All configuration and secrets are managed via environment variables

Setup Checklist:
1. Create and activate a Python virtual environment.
2. Install dependencies from requirements.txt.
3. Run the app using run.py.
4. Access the web UI and REST API.
5. When the app is successfully running, set environment variables for Azure OpenAI keys and endpoints.
6. Access the web UI and REST API and test the features.
5. Review documentation in README.md for usage and troubleshooting.

Note: Both backend and frontend are implemented in Python only.




Feature-request.md
=====================================================================



The Features which are added for GenAIsummarizer Application are:

1. Multi-format Input Support
- Users can upload or paste text, PDF, DOCX, or provide a web URL.
- The system parses and extracts text from each format.
- If an unsupported format or corrupted file is uploaded, the app displays a clear error message.

2. Configurable Summary Length
- Users can select short, medium, or long summaries.
- API accepts a parameter for summary length.
- Example: summary_length=short|medium|long

3. REST API Endpoints
- Endpoints for submitting documents, retrieving summaries, and batch processing.
- API authentication via JWT tokens.
- Example endpoint: POST /api/summarize
- API returns user-friendly error messages for invalid requests.

4. Web User Interface
- Simple dashboard for uploading files, entering text, and viewing summaries.
- History of previous summaries per user.
- UI is responsive and accessible (keyboard navigation, screen reader support).
- Notifications for completion and errors are shown as popups.

5. Batch Processing
- All actions and errors are logged for audit and debugging.
- User-friendly error messages in UI and API.
- Logs include timestamp, user ID, action, and error details.

6. Logging & Error Handling
- All actions and errors are logged for audit and debugging.
- User-friendly error messages in UI and API.

Note: Both the web UI and REST API are implemented in Python only.

User Request Example:
As a user, I want to upload a PDF and receive a short summary, so I can quickly understand the document content.



architecture.md

I want to build a GenAIsummarizer app that will include the following:

- Accepts input as plain text, PDF, DOCX, and web URLs
- Generates concise summaries (configurable length)
- Provides REST API endpoints for integration
- Offers a simple web UI for manual summarization
- Allows batch processing of files
- Logging and error handling

It should be in one app

The directory tree for the GenAIsummarizer App:

summarizer-app/
├── backend/
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py                # Application entry point, starts web server
│   │   ├── api.py                 # REST API endpoints (summarize, batch, history)
│   │   ├── ui.py                  # Web UI backend logic (Python)
│   │   ├── summarizer/
│   │   │   ├── __init__.py
│   │   │   ├── utils.py           # Text extraction, format parsing (PDF, DOCX, URL)
│   │   │   └── engine.py          # Summarization logic, configurable length
│   │   ├── config.py              # App configuration (env vars, summary length)
│   │   ├── logger.py              # Logging setup (actions, errors)
│   │   └── errors.py              # Custom error handling
│   ├── tests/
│   │   ├── test_api.py             # Unit tests for API endpoints
│   │   ├── test_summarizer.py      # Unit tests for summarization logic
│   │   ├── test_auth.py            # Unit tests for authentication
│   │   └── test_history.py         # Unit tests for history tracking
├── frontend/
│   ├── templates/                 # Jinja2 Python templates for UI
│   └── __init__.py                # Python module for frontend logic
└── requirements.txt               # Python dependencies
├── README.md                      # Setup and usage documentation
├── run.py                         # CLI to start app (web server, batch jobs)
└── .env                           # Environment variables (not in version control)
└── startup.sh                     # Startup script for deployment

The files should be organized and created in the above provided directory structure.

The use and function of each file is as follows:
- backend/app/main.py: starts the app, loads config, initializes logger, and mounts API/UI.
- backend/app/api.py: exposes endpoints for summarization, batch processing, and history. Calls summarizer/engine.py for summary generation and history.py for storing/retrieving summaries.
- backend/app/ui.py: serves the dashboard, upload forms, and history views. Communicates with api.py via Python.
- backend/app/summarizer/utils.py: extracts text from PDF, DOCX, or URLs. Used by both API and UI.
- backend/app/summarizer/engine.py: generates summaries based on configurable length. Called by API/UI.
- backend/app/config.py: loads environment variables and settings (e.g., summary length, auth tokens).
- backend/app/logger.py: logs all actions and errors for audit/debugging. Used throughout the app.
- backend/app/errors.py: defines custom error classes and handlers for API/UI.
- frontend/templates/: Jinja2 Python templates for dashboard, upload, history, etc.
- requirements.txt: Python dependencies for backend.
- run.py: CLI to start app (web server, batch jobs).
- .env: Environment variables (not in version control).
- startup.sh: Startup script for deployment (e.g., Azure Web App).


Create a requirements.txt file with the following Python required packages:
fastapi
uvicorn
pydantic
python-docx
PyPDF2
requests
beautifulsoup4
openai
jinja2
python-jose
aiofiles
loguru
python-multipart
python-dotenv

When generating or updating requirements.txt, always copy the full list of Python packages exactly as specified in architecture.md. Do not omit, add, or modify any package names. If requirements.txt already exists, replace its contents with the complete, exact list from architecture.md. Double-check that every package from architecture.md is present in requirements.txt.

When generating or updating run.py, always set the host to "127.0.0.1" for local development. Do not use "0.0.0.0" unless explicitly requested for deployment. The default port should be read from the PORT environment variable, falling back to 8000 if not set.

When generating or updating startup.sh, always use the exact commands and structure as shown below. Do not add, remove, or modify any commands unless explicitly requested. The script must:

- Upgrade pip
- Install dependencies from requirements.txt if it exists
- Start the app using python run.py
- Exit immediately if any command fails
- Print clear status messages for each step
- Example startup.sh:

#!/bin/bash
set -e
echo "=== Installing Python dependencies ==="
if [ -f requirements.txt ]; then
  pip install --upgrade pip
  pip install -r requirements.txt
else
  echo "No requirements.txt found, skipping pip install."
fi
echo "=== Starting the app ==="
python run.py


All the packages listed in requirements.txt file should be installed in the Python environment.

All of the backend app will be in summarizer-app/backend and all frontend files in summarizer-app/frontend.

Both backend and frontend are implemented in Python only.

Use a Python virtual environment and install all python dependencies from backend/requirements.txt in this workspace. To run tests, use pytest from the backend/tests/ directory. Aim for at least 80% code coverage. Store secrets and configuration in environment variables, not in code.

Follow this structure and instructions to avoid errors and ensure a smooth deployment.

Let's think about this step by step.
